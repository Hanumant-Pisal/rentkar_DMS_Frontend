"use client";
import React, { useEffect, useRef, useState, useMemo } from 'react';
import { MapContainer, TileLayer, Marker, Popup, useMap, useMapEvents, Polyline } from 'react-leaflet';
import 'leaflet/dist/leaflet.css';
import L from 'leaflet';
import { Order } from "../../types";

// Fix for default marker icons in Next.js
// @ts-ignore
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
  iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
});

// Custom icons
const pickupIcon = new L.Icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

const deliveryIcon = new L.Icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

const selectedIcon = new L.Icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

interface Location {
  lat: number;
  lng: number;
  address?: string;
}

interface Props {
  orders?: Order[];
  onLocationSelect?: (lat: number, lng: number, address?: string) => void;
  initialLocation?: Location | null;
  showRoute?: boolean;
  fromLocation?: Location | null;
  toLocation?: Location | null;
}

// Component to handle map click events
const LocationMarker = ({ 
  onLocationSelect, 
  initialLocation 
}: { 
  onLocationSelect?: (lat: number, lng: number, address?: string) => void;
  initialLocation?: Location | null;
}) => {
  const [position, setPosition] = useState<[number, number] | null>(
    initialLocation ? [initialLocation.lat, initialLocation.lng] : null
  );
  const map = useMap();

  useEffect(() => {
    if (initialLocation) {
      const newPos: [number, number] = [initialLocation.lat, initialLocation.lng];
      setPosition(newPos);
      map.setView(newPos, 15);
    }
  }, [initialLocation, map]);

  const mapEvents = useMemo(() => ({
    click(e: L.LeafletMouseEvent) {
      if (!onLocationSelect) return;
      
      const { lat, lng } = e.latlng;
      const newPos: [number, number] = [lat, lng];
      setPosition(newPos);
      
      // Try to get address using reverse geocoding
      fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`)
        .then(response => response.json())
        .then(data => {
          const address = data.display_name || '';
          onLocationSelect(lat, lng, address);
        })
        .catch(() => {
          onLocationSelect(lat, lng, '');
        });
    },
  }), [onLocationSelect]);

  useMapEvents(mapEvents);

  if (!position) return null;
  
  return (
    <Marker position={position} icon={selectedIcon}>
      <Popup>Selected Location</Popup>
    </Marker>
  );
};

// Component to display order markers
const OrderMarkers = ({ orders = [] }: { orders: Order[] }) => {
  return (
    <>
      {orders.map((order) => {
        if (!order.deliveryLocation?.coordinates) return null;
        
        const position: [number, number] = [
          order.deliveryLocation.coordinates[1],
          order.deliveryLocation.coordinates[0]
        ];
        
        return (
          <Marker 
            key={order._id} 
            position={position}
            icon={deliveryIcon}
          >
            <Popup>
              <div>
                <p className="font-semibold">Order #{order.orderNumber}</p>
                <p>{order.customerName}</p>
                <p className="text-sm text-gray-600">{order.status}</p>
              </div>
            </Popup>
          </Marker>
        );
      })}
    </>
  );
};

// Component to display route between two points
const Route = ({ from, to }: { from: Location | null; to: Location | null }) => {
  const map = useMap();
  
  useEffect(() => {
    if (from && to) {
      // Fit map to show both points
      const bounds = L.latLngBounds(
        [from.lat, from.lng],
        [to.lat, to.lng]
      );
      map.fitBounds(bounds, { padding: [50, 50] });
    }
  }, [from, to, map]);

  if (!from || !to) return null;

  // Simple straight line for now (you can integrate with a routing service like OSRM for actual routes)
  const positions: [number, number][] = [
    [from.lat, from.lng],
    [to.lat, to.lng]
  ];

  return (
    <Polyline 
      positions={positions} 
      color="#3b82f6" 
      weight={4} 
      opacity={0.7}
      dashArray="10, 10"
    />
  );
};

const DeliveryMap = ({ 
  orders = [], 
  onLocationSelect, 
  initialLocation, 
  showRoute = false,
  fromLocation = null,
  toLocation = null
}: Props) => {
  const mapRef = useRef<L.Map | null>(null);
  const [isClient, setIsClient] = useState(false);

  // Default to Bangalore coordinates
  const defaultCenter: [number, number] = [12.9716, 77.5946];
  
  // Calculate center based on locations
  const center = useMemo(() => {
    if (initialLocation) return [initialLocation.lat, initialLocation.lng];
    if (fromLocation) return [fromLocation.lat, fromLocation.lng];
    if (toLocation) return [toLocation.lat, toLocation.lng];
    return defaultCenter;
  }, [initialLocation, fromLocation, toLocation]);

  // Fix for Next.js SSR
  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) {
    return (
      <div className="h-full w-full bg-gray-800 rounded-md flex items-center justify-center">
        <div className="animate-pulse text-gray-400">Loading map...</div>
      </div>
    );
  }

  return (
    <div className="h-full w-full rounded-md overflow-hidden">
      <MapContainer
        center={center as [number, number]}
        zoom={15}
        style={{ height: '100%', width: '100%' }}
        zoomControl={true}
        ref={mapRef}
      >
        <TileLayer
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        />
        
        {/* Display route if both points are set */}
        {showRoute && fromLocation && toLocation && (
          <Route from={fromLocation} to={toLocation} />
        )}
        
        {/* Show pickup location marker */}
        {fromLocation && (
          <Marker 
            position={[fromLocation.lat, fromLocation.lng]} 
            icon={pickupIcon}
          >
            <Popup>Pickup Location</Popup>
          </Marker>
        )}
        
        {/* Show delivery location marker */}
        {toLocation && (
          <Marker 
            position={[toLocation.lat, toLocation.lng]} 
            icon={deliveryIcon}
          >
            <Popup>Delivery Location</Popup>
          </Marker>
        )}
        
        {/* Show location selector if onLocationSelect is provided */}
        {onLocationSelect && (
          <LocationMarker 
            onLocationSelect={onLocationSelect} 
            initialLocation={initialLocation || undefined}
          />
        )}
        
        {/* Show other order markers */}
        <OrderMarkers orders={orders} />
      </MapContainer>
    </div>
  );
};

export default DeliveryMap;
